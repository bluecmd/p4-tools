#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class BmMatchParamType(object):
    EXACT = 0
    LPM = 1
    TERNARY = 2
    VALID = 3
    RANGE = 4

    _VALUES_TO_NAMES = {
        0: "EXACT",
        1: "LPM",
        2: "TERNARY",
        3: "VALID",
        4: "RANGE",
    }

    _NAMES_TO_VALUES = {
        "EXACT": 0,
        "LPM": 1,
        "TERNARY": 2,
        "VALID": 3,
        "RANGE": 4,
    }


class TableOperationErrorCode(object):
    TABLE_FULL = 1
    INVALID_HANDLE = 2
    EXPIRED_HANDLE = 3
    COUNTERS_DISABLED = 4
    METERS_DISABLED = 5
    AGEING_DISABLED = 6
    INVALID_TABLE_NAME = 7
    INVALID_ACTION_NAME = 8
    WRONG_TABLE_TYPE = 9
    INVALID_MBR_HANDLE = 10
    MBR_STILL_USED = 11
    MBR_ALREADY_IN_GRP = 12
    MBR_NOT_IN_GRP = 13
    INVALID_GRP_HANDLE = 14
    GRP_STILL_USED = 15
    EMPTY_GRP = 16
    DUPLICATE_ENTRY = 17
    BAD_MATCH_KEY = 18
    INVALID_METER_OPERATION = 19
    DEFAULT_ACTION_IS_CONST = 20
    DEFAULT_ENTRY_IS_CONST = 21
    NO_DEFAULT_ENTRY = 22
    INVALID_ACTION_PROFILE_NAME = 23
    NO_ACTION_PROFILE_SELECTION = 24
    IMMUTABLE_TABLE_ENTRIES = 25
    BAD_ACTION_DATA = 26
    ERROR = 100

    _VALUES_TO_NAMES = {
        1: "TABLE_FULL",
        2: "INVALID_HANDLE",
        3: "EXPIRED_HANDLE",
        4: "COUNTERS_DISABLED",
        5: "METERS_DISABLED",
        6: "AGEING_DISABLED",
        7: "INVALID_TABLE_NAME",
        8: "INVALID_ACTION_NAME",
        9: "WRONG_TABLE_TYPE",
        10: "INVALID_MBR_HANDLE",
        11: "MBR_STILL_USED",
        12: "MBR_ALREADY_IN_GRP",
        13: "MBR_NOT_IN_GRP",
        14: "INVALID_GRP_HANDLE",
        15: "GRP_STILL_USED",
        16: "EMPTY_GRP",
        17: "DUPLICATE_ENTRY",
        18: "BAD_MATCH_KEY",
        19: "INVALID_METER_OPERATION",
        20: "DEFAULT_ACTION_IS_CONST",
        21: "DEFAULT_ENTRY_IS_CONST",
        22: "NO_DEFAULT_ENTRY",
        23: "INVALID_ACTION_PROFILE_NAME",
        24: "NO_ACTION_PROFILE_SELECTION",
        25: "IMMUTABLE_TABLE_ENTRIES",
        26: "BAD_ACTION_DATA",
        100: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "TABLE_FULL": 1,
        "INVALID_HANDLE": 2,
        "EXPIRED_HANDLE": 3,
        "COUNTERS_DISABLED": 4,
        "METERS_DISABLED": 5,
        "AGEING_DISABLED": 6,
        "INVALID_TABLE_NAME": 7,
        "INVALID_ACTION_NAME": 8,
        "WRONG_TABLE_TYPE": 9,
        "INVALID_MBR_HANDLE": 10,
        "MBR_STILL_USED": 11,
        "MBR_ALREADY_IN_GRP": 12,
        "MBR_NOT_IN_GRP": 13,
        "INVALID_GRP_HANDLE": 14,
        "GRP_STILL_USED": 15,
        "EMPTY_GRP": 16,
        "DUPLICATE_ENTRY": 17,
        "BAD_MATCH_KEY": 18,
        "INVALID_METER_OPERATION": 19,
        "DEFAULT_ACTION_IS_CONST": 20,
        "DEFAULT_ENTRY_IS_CONST": 21,
        "NO_DEFAULT_ENTRY": 22,
        "INVALID_ACTION_PROFILE_NAME": 23,
        "NO_ACTION_PROFILE_SELECTION": 24,
        "IMMUTABLE_TABLE_ENTRIES": 25,
        "BAD_ACTION_DATA": 26,
        "ERROR": 100,
    }


class CounterOperationErrorCode(object):
    INVALID_COUNTER_NAME = 1
    INVALID_INDEX = 2
    ERROR = 3

    _VALUES_TO_NAMES = {
        1: "INVALID_COUNTER_NAME",
        2: "INVALID_INDEX",
        3: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "INVALID_COUNTER_NAME": 1,
        "INVALID_INDEX": 2,
        "ERROR": 3,
    }


class SwapOperationErrorCode(object):
    CONFIG_SWAP_DISABLED = 1
    ONGOING_SWAP = 2
    NO_ONGOING_SWAP = 3

    _VALUES_TO_NAMES = {
        1: "CONFIG_SWAP_DISABLED",
        2: "ONGOING_SWAP",
        3: "NO_ONGOING_SWAP",
    }

    _NAMES_TO_VALUES = {
        "CONFIG_SWAP_DISABLED": 1,
        "ONGOING_SWAP": 2,
        "NO_ONGOING_SWAP": 3,
    }


class MeterOperationErrorCode(object):
    INVALID_METER_NAME = 1
    INVALID_INDEX = 2
    BAD_RATES_LIST = 3
    INVALID_INFO_RATE_VALUE = 4
    INVALID_BURST_SIZE_VALUE = 5
    ERROR = 6

    _VALUES_TO_NAMES = {
        1: "INVALID_METER_NAME",
        2: "INVALID_INDEX",
        3: "BAD_RATES_LIST",
        4: "INVALID_INFO_RATE_VALUE",
        5: "INVALID_BURST_SIZE_VALUE",
        6: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "INVALID_METER_NAME": 1,
        "INVALID_INDEX": 2,
        "BAD_RATES_LIST": 3,
        "INVALID_INFO_RATE_VALUE": 4,
        "INVALID_BURST_SIZE_VALUE": 5,
        "ERROR": 6,
    }


class RegisterOperationErrorCode(object):
    INVALID_REGISTER_NAME = 1
    INVALID_INDEX = 2
    ERROR = 3

    _VALUES_TO_NAMES = {
        1: "INVALID_REGISTER_NAME",
        2: "INVALID_INDEX",
        3: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "INVALID_REGISTER_NAME": 1,
        "INVALID_INDEX": 2,
        "ERROR": 3,
    }


class ParseVSetOperationErrorCode(object):
    INVALID_PARSE_VSET_NAME = 1
    ERROR = 2

    _VALUES_TO_NAMES = {
        1: "INVALID_PARSE_VSET_NAME",
        2: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "INVALID_PARSE_VSET_NAME": 1,
        "ERROR": 2,
    }


class LearnOperationErrorCode(object):
    INVALID_LIST_ID = 1
    INVALID_LIST_NAME = 2
    ERROR = 3

    _VALUES_TO_NAMES = {
        1: "INVALID_LIST_ID",
        2: "INVALID_LIST_NAME",
        3: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "INVALID_LIST_ID": 1,
        "INVALID_LIST_NAME": 2,
        "ERROR": 3,
    }


class DevMgrErrorCode(object):
    ERROR = 1

    _VALUES_TO_NAMES = {
        1: "ERROR",
    }

    _NAMES_TO_VALUES = {
        "ERROR": 1,
    }


class CrcErrorCode(object):
    INVALID_CALCULATION_NAME = 1
    WRONG_TYPE_CALCULATION = 2
    INVALID_CONFIG = 3

    _VALUES_TO_NAMES = {
        1: "INVALID_CALCULATION_NAME",
        2: "WRONG_TYPE_CALCULATION",
        3: "INVALID_CONFIG",
    }

    _NAMES_TO_VALUES = {
        "INVALID_CALCULATION_NAME": 1,
        "WRONG_TYPE_CALCULATION": 2,
        "INVALID_CONFIG": 3,
    }


class BmActionEntryType(object):
    NONE = 0
    ACTION_DATA = 1
    MBR_HANDLE = 2
    GRP_HANDLE = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "ACTION_DATA",
        2: "MBR_HANDLE",
        3: "GRP_HANDLE",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "ACTION_DATA": 1,
        "MBR_HANDLE": 2,
        "GRP_HANDLE": 3,
    }


class BmResourceType(object):
    MATCH_TABLE = 0
    ACTION_PROFILE = 1
    COUNTER = 2
    METER = 3
    REGISTER = 4
    LEARNING_LIST = 5

    _VALUES_TO_NAMES = {
        0: "MATCH_TABLE",
        1: "ACTION_PROFILE",
        2: "COUNTER",
        3: "METER",
        4: "REGISTER",
        5: "LEARNING_LIST",
    }

    _NAMES_TO_VALUES = {
        "MATCH_TABLE": 0,
        "ACTION_PROFILE": 1,
        "COUNTER": 2,
        "METER": 3,
        "REGISTER": 4,
        "LEARNING_LIST": 5,
    }


class IdLookupErrorCode(object):
    INVALID_RESOURCE_TYPE = 0
    INVALID_RESOURCE_NAME = 1

    _VALUES_TO_NAMES = {
        0: "INVALID_RESOURCE_TYPE",
        1: "INVALID_RESOURCE_NAME",
    }

    _NAMES_TO_VALUES = {
        "INVALID_RESOURCE_TYPE": 0,
        "INVALID_RESOURCE_NAME": 1,
    }


class BmMatchParamExact(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMatchParamExact')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeBinary(self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMatchParamLPM(object):
    """
    Attributes:
     - key
     - prefix_length

    """


    def __init__(self, key=None, prefix_length=None,):
        self.key = key
        self.prefix_length = prefix_length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.prefix_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMatchParamLPM')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeBinary(self.key)
            oprot.writeFieldEnd()
        if self.prefix_length is not None:
            oprot.writeFieldBegin('prefix_length', TType.I32, 2)
            oprot.writeI32(self.prefix_length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMatchParamTernary(object):
    """
    Attributes:
     - key
     - mask

    """


    def __init__(self, key=None, mask=None,):
        self.key = key
        self.mask = mask

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mask = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMatchParamTernary')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeBinary(self.key)
            oprot.writeFieldEnd()
        if self.mask is not None:
            oprot.writeFieldBegin('mask', TType.STRING, 2)
            oprot.writeBinary(self.mask)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMatchParamValid(object):
    """
    Attributes:
     - key

    """


    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.key = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMatchParamValid')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.BOOL, 1)
            oprot.writeBool(self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMatchParamRange(object):
    """
    Attributes:
     - start
     - end_

    """


    def __init__(self, start=None, end_=None,):
        self.start = start
        self.end_ = end_

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.start = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.end_ = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMatchParamRange')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.STRING, 1)
            oprot.writeBinary(self.start)
            oprot.writeFieldEnd()
        if self.end_ is not None:
            oprot.writeFieldBegin('end_', TType.STRING, 2)
            oprot.writeBinary(self.end_)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMatchParam(object):
    """
    Attributes:
     - type
     - exact
     - lpm
     - ternary
     - valid
     - range

    """


    def __init__(self, type=None, exact=None, lpm=None, ternary=None, valid=None, range=None,):
        self.type = type
        self.exact = exact
        self.lpm = lpm
        self.ternary = ternary
        self.valid = valid
        self.range = range

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.exact = BmMatchParamExact()
                    self.exact.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.lpm = BmMatchParamLPM()
                    self.lpm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ternary = BmMatchParamTernary()
                    self.ternary.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.valid = BmMatchParamValid()
                    self.valid.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.range = BmMatchParamRange()
                    self.range.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMatchParam')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.exact is not None:
            oprot.writeFieldBegin('exact', TType.STRUCT, 2)
            self.exact.write(oprot)
            oprot.writeFieldEnd()
        if self.lpm is not None:
            oprot.writeFieldBegin('lpm', TType.STRUCT, 3)
            self.lpm.write(oprot)
            oprot.writeFieldEnd()
        if self.ternary is not None:
            oprot.writeFieldBegin('ternary', TType.STRUCT, 4)
            self.ternary.write(oprot)
            oprot.writeFieldEnd()
        if self.valid is not None:
            oprot.writeFieldBegin('valid', TType.STRUCT, 5)
            self.valid.write(oprot)
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.STRUCT, 6)
            self.range.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmAddEntryOptions(object):
    """
    Attributes:
     - priority

    """


    def __init__(self, priority=None,):
        self.priority = priority

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.priority = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmAddEntryOptions')
        if self.priority is not None:
            oprot.writeFieldBegin('priority', TType.I32, 1)
            oprot.writeI32(self.priority)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmCounterValue(object):
    """
    Attributes:
     - bytes
     - packets

    """


    def __init__(self, bytes=None, packets=None,):
        self.bytes = bytes
        self.packets = packets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.packets = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmCounterValue')
        if self.bytes is not None:
            oprot.writeFieldBegin('bytes', TType.I64, 1)
            oprot.writeI64(self.bytes)
            oprot.writeFieldEnd()
        if self.packets is not None:
            oprot.writeFieldBegin('packets', TType.I64, 2)
            oprot.writeI64(self.packets)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMeterRateConfig(object):
    """
    Attributes:
     - units_per_micros
     - burst_size

    """


    def __init__(self, units_per_micros=None, burst_size=None,):
        self.units_per_micros = units_per_micros
        self.burst_size = burst_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.units_per_micros = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.burst_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMeterRateConfig')
        if self.units_per_micros is not None:
            oprot.writeFieldBegin('units_per_micros', TType.DOUBLE, 1)
            oprot.writeDouble(self.units_per_micros)
            oprot.writeFieldEnd()
        if self.burst_size is not None:
            oprot.writeFieldBegin('burst_size', TType.I32, 2)
            oprot.writeI32(self.burst_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidTableOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidTableOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidCounterOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidCounterOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidSwapOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidSwapOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidMeterOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidMeterOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidRegisterOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidRegisterOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidParseVSetOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidParseVSetOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidLearnOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidLearnOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidDevMgrOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidDevMgrOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DevMgrPortInfo(object):
    """
    Attributes:
     - port_num
     - iface_name
     - is_up
     - extra

    """


    def __init__(self, port_num=None, iface_name=None, is_up=None, extra=None,):
        self.port_num = port_num
        self.iface_name = iface_name
        self.is_up = is_up
        self.extra = extra

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.port_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.iface_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_up = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.extra = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.extra[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DevMgrPortInfo')
        if self.port_num is not None:
            oprot.writeFieldBegin('port_num', TType.I32, 1)
            oprot.writeI32(self.port_num)
            oprot.writeFieldEnd()
        if self.iface_name is not None:
            oprot.writeFieldBegin('iface_name', TType.STRING, 2)
            oprot.writeString(self.iface_name.encode('utf-8') if sys.version_info[0] == 2 else self.iface_name)
            oprot.writeFieldEnd()
        if self.is_up is not None:
            oprot.writeFieldBegin('is_up', TType.BOOL, 3)
            oprot.writeBool(self.is_up)
            oprot.writeFieldEnd()
        if self.extra is not None:
            oprot.writeFieldBegin('extra', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.extra))
            for kiter7, viter8 in self.extra.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                oprot.writeString(viter8.encode('utf-8') if sys.version_info[0] == 2 else viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmCrc16Config(object):
    """
    Attributes:
     - polynomial
     - initial_remainder
     - final_xor_value
     - data_reflected
     - remainder_reflected

    """


    def __init__(self, polynomial=None, initial_remainder=None, final_xor_value=None, data_reflected=None, remainder_reflected=None,):
        self.polynomial = polynomial
        self.initial_remainder = initial_remainder
        self.final_xor_value = final_xor_value
        self.data_reflected = data_reflected
        self.remainder_reflected = remainder_reflected

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.polynomial = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.initial_remainder = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.final_xor_value = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.data_reflected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.remainder_reflected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmCrc16Config')
        if self.polynomial is not None:
            oprot.writeFieldBegin('polynomial', TType.I16, 1)
            oprot.writeI16(self.polynomial)
            oprot.writeFieldEnd()
        if self.initial_remainder is not None:
            oprot.writeFieldBegin('initial_remainder', TType.I16, 2)
            oprot.writeI16(self.initial_remainder)
            oprot.writeFieldEnd()
        if self.final_xor_value is not None:
            oprot.writeFieldBegin('final_xor_value', TType.I16, 3)
            oprot.writeI16(self.final_xor_value)
            oprot.writeFieldEnd()
        if self.data_reflected is not None:
            oprot.writeFieldBegin('data_reflected', TType.BOOL, 4)
            oprot.writeBool(self.data_reflected)
            oprot.writeFieldEnd()
        if self.remainder_reflected is not None:
            oprot.writeFieldBegin('remainder_reflected', TType.BOOL, 5)
            oprot.writeBool(self.remainder_reflected)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmCrc32Config(object):
    """
    Attributes:
     - polynomial
     - initial_remainder
     - final_xor_value
     - data_reflected
     - remainder_reflected

    """


    def __init__(self, polynomial=None, initial_remainder=None, final_xor_value=None, data_reflected=None, remainder_reflected=None,):
        self.polynomial = polynomial
        self.initial_remainder = initial_remainder
        self.final_xor_value = final_xor_value
        self.data_reflected = data_reflected
        self.remainder_reflected = remainder_reflected

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.polynomial = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.initial_remainder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.final_xor_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.data_reflected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.remainder_reflected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmCrc32Config')
        if self.polynomial is not None:
            oprot.writeFieldBegin('polynomial', TType.I32, 1)
            oprot.writeI32(self.polynomial)
            oprot.writeFieldEnd()
        if self.initial_remainder is not None:
            oprot.writeFieldBegin('initial_remainder', TType.I32, 2)
            oprot.writeI32(self.initial_remainder)
            oprot.writeFieldEnd()
        if self.final_xor_value is not None:
            oprot.writeFieldBegin('final_xor_value', TType.I32, 3)
            oprot.writeI32(self.final_xor_value)
            oprot.writeFieldEnd()
        if self.data_reflected is not None:
            oprot.writeFieldBegin('data_reflected', TType.BOOL, 4)
            oprot.writeBool(self.data_reflected)
            oprot.writeFieldEnd()
        if self.remainder_reflected is not None:
            oprot.writeFieldBegin('remainder_reflected', TType.BOOL, 5)
            oprot.writeBool(self.remainder_reflected)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidCrcOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidCrcOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmActionEntry(object):
    """
    Attributes:
     - action_type
     - action_name
     - action_data
     - mbr_handle
     - grp_handle

    """


    def __init__(self, action_type=None, action_name=None, action_data=None, mbr_handle=None, grp_handle=None,):
        self.action_type = action_type
        self.action_name = action_name
        self.action_data = action_data
        self.mbr_handle = mbr_handle
        self.grp_handle = grp_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.action_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.action_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.action_data = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = iprot.readBinary()
                        self.action_data.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mbr_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.grp_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmActionEntry')
        if self.action_type is not None:
            oprot.writeFieldBegin('action_type', TType.I32, 1)
            oprot.writeI32(self.action_type)
            oprot.writeFieldEnd()
        if self.action_name is not None:
            oprot.writeFieldBegin('action_name', TType.STRING, 2)
            oprot.writeString(self.action_name.encode('utf-8') if sys.version_info[0] == 2 else self.action_name)
            oprot.writeFieldEnd()
        if self.action_data is not None:
            oprot.writeFieldBegin('action_data', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.action_data))
            for iter15 in self.action_data:
                oprot.writeBinary(iter15)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mbr_handle is not None:
            oprot.writeFieldBegin('mbr_handle', TType.I32, 4)
            oprot.writeI32(self.mbr_handle)
            oprot.writeFieldEnd()
        if self.grp_handle is not None:
            oprot.writeFieldBegin('grp_handle', TType.I32, 5)
            oprot.writeI32(self.grp_handle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMtEntryLife(object):
    """
    Attributes:
     - timeout_ms
     - time_since_hit_ms

    """


    def __init__(self, timeout_ms=None, time_since_hit_ms=None,):
        self.timeout_ms = timeout_ms
        self.time_since_hit_ms = time_since_hit_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.timeout_ms = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.time_since_hit_ms = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMtEntryLife')
        if self.timeout_ms is not None:
            oprot.writeFieldBegin('timeout_ms', TType.I32, 1)
            oprot.writeI32(self.timeout_ms)
            oprot.writeFieldEnd()
        if self.time_since_hit_ms is not None:
            oprot.writeFieldBegin('time_since_hit_ms', TType.I32, 2)
            oprot.writeI32(self.time_since_hit_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMtEntry(object):
    """
    Attributes:
     - match_key
     - options
     - entry_handle
     - action_entry
     - life

    """


    def __init__(self, match_key=None, options=None, entry_handle=None, action_entry=None, life=None,):
        self.match_key = match_key
        self.options = options
        self.entry_handle = entry_handle
        self.action_entry = action_entry
        self.life = life

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.match_key = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = BmMatchParam()
                        _elem21.read(iprot)
                        self.match_key.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.options = BmAddEntryOptions()
                    self.options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_entry = BmActionEntry()
                    self.action_entry.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.life = BmMtEntryLife()
                    self.life.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMtEntry')
        if self.match_key is not None:
            oprot.writeFieldBegin('match_key', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.match_key))
            for iter22 in self.match_key:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.STRUCT, 2)
            self.options.write(oprot)
            oprot.writeFieldEnd()
        if self.entry_handle is not None:
            oprot.writeFieldBegin('entry_handle', TType.I32, 3)
            oprot.writeI32(self.entry_handle)
            oprot.writeFieldEnd()
        if self.action_entry is not None:
            oprot.writeFieldBegin('action_entry', TType.STRUCT, 4)
            self.action_entry.write(oprot)
            oprot.writeFieldEnd()
        if self.life is not None:
            oprot.writeFieldBegin('life', TType.STRUCT, 5)
            self.life.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMtActProfMember(object):
    """
    Attributes:
     - mbr_handle
     - action_name
     - action_data

    """


    def __init__(self, mbr_handle=None, action_name=None, action_data=None,):
        self.mbr_handle = mbr_handle
        self.action_name = action_name
        self.action_data = action_data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mbr_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.action_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.action_data = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = iprot.readBinary()
                        self.action_data.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMtActProfMember')
        if self.mbr_handle is not None:
            oprot.writeFieldBegin('mbr_handle', TType.I32, 1)
            oprot.writeI32(self.mbr_handle)
            oprot.writeFieldEnd()
        if self.action_name is not None:
            oprot.writeFieldBegin('action_name', TType.STRING, 2)
            oprot.writeString(self.action_name.encode('utf-8') if sys.version_info[0] == 2 else self.action_name)
            oprot.writeFieldEnd()
        if self.action_data is not None:
            oprot.writeFieldBegin('action_data', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.action_data))
            for iter29 in self.action_data:
                oprot.writeBinary(iter29)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmMtActProfGroup(object):
    """
    Attributes:
     - grp_handle
     - mbr_handles

    """


    def __init__(self, grp_handle=None, mbr_handles=None,):
        self.grp_handle = grp_handle
        self.mbr_handles = mbr_handles

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.grp_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.mbr_handles = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readI32()
                        self.mbr_handles.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmMtActProfGroup')
        if self.grp_handle is not None:
            oprot.writeFieldBegin('grp_handle', TType.I32, 1)
            oprot.writeI32(self.grp_handle)
            oprot.writeFieldEnd()
        if self.mbr_handles is not None:
            oprot.writeFieldBegin('mbr_handles', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.mbr_handles))
            for iter36 in self.mbr_handles:
                oprot.writeI32(iter36)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BmConfig(object):
    """
    Attributes:
     - device_id
     - thrift_port
     - notifications_socket
     - elogger_socket
     - debugger_socket

    """


    def __init__(self, device_id=None, thrift_port=None, notifications_socket=None, elogger_socket=None, debugger_socket=None,):
        self.device_id = device_id
        self.thrift_port = thrift_port
        self.notifications_socket = notifications_socket
        self.elogger_socket = elogger_socket
        self.debugger_socket = debugger_socket

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.device_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.thrift_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.notifications_socket = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.elogger_socket = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.debugger_socket = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BmConfig')
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I64, 1)
            oprot.writeI64(self.device_id)
            oprot.writeFieldEnd()
        if self.thrift_port is not None:
            oprot.writeFieldBegin('thrift_port', TType.I32, 2)
            oprot.writeI32(self.thrift_port)
            oprot.writeFieldEnd()
        if self.notifications_socket is not None:
            oprot.writeFieldBegin('notifications_socket', TType.STRING, 3)
            oprot.writeString(self.notifications_socket.encode('utf-8') if sys.version_info[0] == 2 else self.notifications_socket)
            oprot.writeFieldEnd()
        if self.elogger_socket is not None:
            oprot.writeFieldBegin('elogger_socket', TType.STRING, 4)
            oprot.writeString(self.elogger_socket.encode('utf-8') if sys.version_info[0] == 2 else self.elogger_socket)
            oprot.writeFieldEnd()
        if self.debugger_socket is not None:
            oprot.writeFieldBegin('debugger_socket', TType.STRING, 5)
            oprot.writeString(self.debugger_socket.encode('utf-8') if sys.version_info[0] == 2 else self.debugger_socket)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidIdLookup(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        self.code = code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidIdLookup')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(BmMatchParamExact)
BmMatchParamExact.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'BINARY', None, ),  # 1
)
all_structs.append(BmMatchParamLPM)
BmMatchParamLPM.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'BINARY', None, ),  # 1
    (2, TType.I32, 'prefix_length', None, None, ),  # 2
)
all_structs.append(BmMatchParamTernary)
BmMatchParamTernary.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'mask', 'BINARY', None, ),  # 2
)
all_structs.append(BmMatchParamValid)
BmMatchParamValid.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'key', None, None, ),  # 1
)
all_structs.append(BmMatchParamRange)
BmMatchParamRange.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'start', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'end_', 'BINARY', None, ),  # 2
)
all_structs.append(BmMatchParam)
BmMatchParam.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'exact', [BmMatchParamExact, None], None, ),  # 2
    (3, TType.STRUCT, 'lpm', [BmMatchParamLPM, None], None, ),  # 3
    (4, TType.STRUCT, 'ternary', [BmMatchParamTernary, None], None, ),  # 4
    (5, TType.STRUCT, 'valid', [BmMatchParamValid, None], None, ),  # 5
    (6, TType.STRUCT, 'range', [BmMatchParamRange, None], None, ),  # 6
)
all_structs.append(BmAddEntryOptions)
BmAddEntryOptions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'priority', None, None, ),  # 1
)
all_structs.append(BmCounterValue)
BmCounterValue.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'bytes', None, None, ),  # 1
    (2, TType.I64, 'packets', None, None, ),  # 2
)
all_structs.append(BmMeterRateConfig)
BmMeterRateConfig.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'units_per_micros', None, None, ),  # 1
    (2, TType.I32, 'burst_size', None, None, ),  # 2
)
all_structs.append(InvalidTableOperation)
InvalidTableOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidCounterOperation)
InvalidCounterOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidSwapOperation)
InvalidSwapOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidMeterOperation)
InvalidMeterOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidRegisterOperation)
InvalidRegisterOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidParseVSetOperation)
InvalidParseVSetOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidLearnOperation)
InvalidLearnOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidDevMgrOperation)
InvalidDevMgrOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(DevMgrPortInfo)
DevMgrPortInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'port_num', None, None, ),  # 1
    (2, TType.STRING, 'iface_name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'is_up', None, None, ),  # 3
    (4, TType.MAP, 'extra', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(BmCrc16Config)
BmCrc16Config.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'polynomial', None, None, ),  # 1
    (2, TType.I16, 'initial_remainder', None, None, ),  # 2
    (3, TType.I16, 'final_xor_value', None, None, ),  # 3
    (4, TType.BOOL, 'data_reflected', None, None, ),  # 4
    (5, TType.BOOL, 'remainder_reflected', None, None, ),  # 5
)
all_structs.append(BmCrc32Config)
BmCrc32Config.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'polynomial', None, None, ),  # 1
    (2, TType.I32, 'initial_remainder', None, None, ),  # 2
    (3, TType.I32, 'final_xor_value', None, None, ),  # 3
    (4, TType.BOOL, 'data_reflected', None, None, ),  # 4
    (5, TType.BOOL, 'remainder_reflected', None, None, ),  # 5
)
all_structs.append(InvalidCrcOperation)
InvalidCrcOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(BmActionEntry)
BmActionEntry.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'action_type', None, None, ),  # 1
    (2, TType.STRING, 'action_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'action_data', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I32, 'mbr_handle', None, None, ),  # 4
    (5, TType.I32, 'grp_handle', None, None, ),  # 5
)
all_structs.append(BmMtEntryLife)
BmMtEntryLife.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'timeout_ms', None, None, ),  # 1
    (2, TType.I32, 'time_since_hit_ms', None, None, ),  # 2
)
all_structs.append(BmMtEntry)
BmMtEntry.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'match_key', (TType.STRUCT, [BmMatchParam, None], False), None, ),  # 1
    (2, TType.STRUCT, 'options', [BmAddEntryOptions, None], None, ),  # 2
    (3, TType.I32, 'entry_handle', None, None, ),  # 3
    (4, TType.STRUCT, 'action_entry', [BmActionEntry, None], None, ),  # 4
    (5, TType.STRUCT, 'life', [BmMtEntryLife, None], None, ),  # 5
)
all_structs.append(BmMtActProfMember)
BmMtActProfMember.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mbr_handle', None, None, ),  # 1
    (2, TType.STRING, 'action_name', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'action_data', (TType.STRING, 'BINARY', False), None, ),  # 3
)
all_structs.append(BmMtActProfGroup)
BmMtActProfGroup.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'grp_handle', None, None, ),  # 1
    (2, TType.LIST, 'mbr_handles', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(BmConfig)
BmConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'device_id', None, None, ),  # 1
    (2, TType.I32, 'thrift_port', None, None, ),  # 2
    (3, TType.STRING, 'notifications_socket', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'elogger_socket', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'debugger_socket', 'UTF8', None, ),  # 5
)
all_structs.append(InvalidIdLookup)
InvalidIdLookup.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
fix_spec(all_structs)
del all_structs
